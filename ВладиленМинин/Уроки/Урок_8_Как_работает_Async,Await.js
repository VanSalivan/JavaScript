//? ассинхронная функция для возврата промиса
//* 1)Babel - транспайлер позволяет использовать Async / Await и переводит эту конструкцию в Promises

const delay = milliSeconds => { // параметр количества Миллисекунд
    return new Promise(resoult => { // Возвращает новый промис
        setTimeout(() => resoult(), milliSeconds) // Ассинхронно выполняет параметр-функцию через миллисекунды 
    })
};

const url = 'https://jsonplaceholder.typicode.com/todos';

//=================================================================
//* Promises
// function fetchTodos() {
//     console.log('Fetch todo started...');
//     return delay(2000) // возвращает промис создаваемый функцей выше "delay"
//         .then(() => { // "затем" после успешно выполенно запроса возвращает 
//             return fetch(url) // это простой GET-запрос, скачивающий содержимое по адресу url.
//         })
//         .then(response => response.json()) // затем полученный обьект превращаем в json
// }

// // Поскольку это функция нам нужно ее вызвать
// fetchTodos()
//     .then(data => { // полученные данные json записываем параметром
//         console.log('Data:', data)
//     })
//     .catch(e => console.error(e)) // логика обработки ошибки в запросе

//=================================================================
//* Async / Await

async function fetchAsyncTodos() { // функция обязательно должна быть асинхронной
    try { // блок попробую - позитивно выполненный запрос
        await delay(2000) // "await"- ожидает выполнения функции возвращающей промис
        // не преступит к этой стройке пока не выполниться предыдущая с оператором "await"
        const response = await fetch(url) // "await" - позволяет обработать этот промис, результат которого сохраняем в переменную
        const data = await response.json() // Дожидаемся ответа полученного в json

        console.log('Data:', data)
    } catch (e) { // блок поймай - ошибка при выполнении запроса
        console.error(e)
    } finally { // Выполниться в любом случае в конце
        console.log('Выполниться в любом случае в конце')
    }
}

// Вызываем функцию которую мы определели
fetchAsyncTodos()